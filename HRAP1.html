<!DOCTYPE html>
<html lang = "en">
<head>
    <meta charset="utf-8">
    <title>HRAP
    </title>
    <script src="https://d3js.org/d3.v5.min.js" charset="utf-8"></script>
    <script src="http://d3js.org/colorbrewer.v1.min.js"></script>

    <style type="text/css">


    </style>

</head>

<body>

<svg id="key1"></svg>
<script type="text/javascript">
// create an SVG region
const width = 800, height = 500;
const svg = d3.select("body")
				.append("svg")
				.attr("width", width)
				.attr("height", height);


const color = d3.scaleSequential(d3.interpolateBuGn)

// Add a legend for the color values.
  var legend = svg.selectAll("#key1")
      .data(color.ticks(6).slice(1).reverse())
    .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (0) + "," + (20 + i * 20) + ")"; });

  legend.append("rect")
      .attr("width", 20)
      .attr("height", 20)
      .style("fill", color);

  legend.append("text")
      .attr("x", 26)
      .attr("y", 10)
      .attr("dy", ".35em")
      .text(String);

  svg.append("text")
      .attr("class", "label")
      .attr("x", width + 20)
      .attr("y", 10)
      .attr("dy", ".35em")
      .text("Count");


// set-up unit projection and path
 var projection = d3.geoMercator()
     .translate([width, height])


// create a path tool that will translate GeoJSON into SVG path data
 var path = d3.geoPath()
     .projection(projection);

 // create our coloring tool
 // const color = d3.scaleQuantize()
 // .range(colorbrewer.YlGnBu[8].reverse());

   //.range(["#33FF6B", "#FF3333"]);

//TODO: add interaction to select metric
let metric="Developmental_Screening_Rate";


// fetch our data -- first the map, and then the CSV data (the order matters little here since we
// are not displaying anything until the binding is done)
Promise.all([
d3.json("hsa.geojson"),
d3.csv("HRAP_Data.csv")
]).then(function(data){
    console.log(data[0])
    console.log(data[1])
    const map_data = data[0];
    const hrap_data = data[1];


    var menu = d3.select("#metrics");
		for (prop in hrap_data[0]){
			if (prop != "HSA_NAME"){
				menu.append("option").attr("value",prop).text(prop);
			}
		}
    // set the behavior on a change to the menu (i.e., update the coloring)
    		d3.select("select").on("change", function () {
    			setMetric(this.value);
    			});


    projection.fitExtent([[20, 20], [940, 480]], map_data);

    // set the domain for our color scale now that we have data
    color.domain(d3.extent(hrap_data, (d) => +d[metric]));

    // create a map of our census data, so we can easily find records
    // corresponding to a particular state
    const hsa_map = d3.map();
    hrap_data.forEach((d)=> {hsa_map.set(d["HSA_NAME"],d)});

    // loop through all of the path data, attaching the appropriate
    // record to each one based on the name
    for (let i = 0; i < map_data.features.length; i++){
        let name = map_data.features[i].properties["HSA_NAME"];
        map_data.features[i].properties.value = hsa_map.get(name);
    }

    // create the states in the SVG
    const serviceAreas = svg.selectAll("path")
        .data(map_data.features)
        .enter()
        .append("path")
        .attr("d", path)
        .attr("class","hsa")

        function setMetric(metric){
    			color.domain(d3.extent(hrap_data, (d) => +d[metric]));
                    serviceAreas.transition()
				    .duration(1500)
                    .style("fill", function(d){
                        if (d.properties.value){
                            return color(+d.properties.value[metric]);
                        }	else{
                            return "red";
                        }

                    });


    		}
    setMetric("Developmental Screening")


});


</script>
<select><optgroup label="Metrics" id="metrics"></optgroup></select>

    </body>
</html>
